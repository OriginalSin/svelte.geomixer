<li class="line cmd:toggleIcons id:{nodeID}">
{#if properties}
	{#if line.type !== 'map'}
	<div class="borders "></div>
	<input class="expander hidden" type="checkbox" checked={properties.expanded ? true : false} />
	<span class="expander pointer cmd:toggleFolder expanderCont {line.content.children ? '' : 'hidden'}"><svg role="img" class="svgIcon"><use xlink:href="#arrow-small-down" href="#arrow-small-down"></use></svg></span>
		{#if line.type === 'layer'}
			{#if properties.styles.length > 1}
	<span class="cont-overlays"><svg role="img" class="svgIcon"><use xlink:href="#overlays" href="#overlays"></use></svg></span>
			{/if}
	<span class="icons ">
 		<span class="pointer cmd:fitBounds cont-center"  title="Move map to this layer"><svg role="img" class="svgIcon"><use xlink:href="#center-on-click" href="#center-on-click"></use></svg></span>
			{#if properties.description}
		<span class="cont-info" title="View description"><svg role="img" class="svgIcon"><use xlink:href="#info-circle-i" href="#info-circle-i"></use></svg></span>
			{/if}
	</span>
		{/if}
	{/if}
		{#if line.type !== 'map'}
	<span class="cont">
			<input class="check visibility pointer cmd:toggleVisibility" type="checkbox" checked={layersTree && layersTree.visible[nodeID] ? true : false}>
			<span class="styleIcon gmx-style-legend">
			{#if styles.length && styles.length < 2 && styles[0].RenderStyle}
				<LegendIconCell item={styles[0]} type={properties.GeometryType} />
			{/if}
			</span>
		<label class="title">{properties.title}</label>
		<div class="description collapse"></div>
		<div class="legend">
			{#if styles.length && styles.length > 1 && styles[0].RenderStyle}
			{#each styles as it}
				<div class="gmx-style-legend">
					<span class="legendIconEye enabled pointer cmd:toggleStyle">
						<svg role="img" class="svgIcon on"><use xlink:href="#eye-on" href="#eye-on"></use></svg>
						<svg role="img" class="svgIcon off"><use xlink:href="#eye-off" href="#eye-off"></use></svg>
					</span>
					<LegendIconCell item={it} type={properties.GeometryType} />
					<span class="legendIconCell"><span class="styleName">{it.Name}</span></span>
				</div>
			{/each}
			{/if}
		</div>
	</span>
		{/if}
{/if}
{#if line.content.children}
	<ul class="group css-treeview id_{properties ? properties.name : 'root'}">
	{#each line.content.children || [] as child}
		<svelte:self line="{child}"  bind:layersTree />
	{/each}
	</ul>
{/if}
</li>
 
<script>
	import LegendIconCell from './LegendIconCell.html';
	export default {
		data() {
			return {
				// layersTree: {
					// visible: {}
				// },
				container: null,
				line: null
			}
		},
		computed: {
			properties: ({ line }) => line.content.properties,
			nodeID: ({ properties }) => properties ? properties.name || properties.GroupID : 'root',
			styles: ({ properties }) => properties.gmxStyles ? properties.gmxStyles.styles : [],
			minutes: ({ line }) => (new Date()).getMinutes(),
			seconds: ({ line }) => (new Date()).getSeconds()
		},
		components: {
			LegendIconCell
		},
		// events: {
			// fitBounds(props, tt) {
// console.log('fitBounds TreeView', props, tt); // true
			// }
			
		// },
		methods: {
			createMap(it) {
		// var type = tItem.type,
			// props = tItem.content.properties,
			// id = props ? props.GroupID || props.name : 'root',
			// tNode = L.DomUtil.create('ul', 'css-treeview node-props-' + id),
			// node = this._addLine(props, type);

			// tNode.appendChild(node);

		// if (tItem.content.children) {	// могут быть потомки
            // for (var i = 0, len = tItem.content.children.length; i < len; i++) {
				// node.appendChild(this._addGroupNode(tItem.content.children[i]));
            // }
		// }
		// return tNode;

			},
			// fitBounds(props) {
// console.log('fitBounds', props, this); // true
				// this.fire('fitBounds', {layerID: props.layerID});
			// },
			expanderChange(ev) {
console.log('expanderChange', ev); // true
			},
			mouseOverOut_bak(ev, flag) {
//			<li class="line cmd:toggleIcons id:{properties ? properties.name : 'root'}" on:mouseover="mouseOverOut(event, true)" on:mouseout="mouseOverOut(event)">

L.DomEvent.stopPropagation(ev);
L.DomEvent.preventDefault(ev);
				let target = ev.target,
					node = target.getElementsByClassName('cont-center')[0];
 console.log('mouseover', flag, node, target); // true
				if (node && target.classList.contains('line')) {
					if (this.prevNode) {
						this.prevNode.style.visibility = 'hidden';
					}
					this.prevNode = node;
					node.style.visibility = flag ? 'visible' : 'hidden';
				}
			}
		},

		onstate({ changed, current, previous }) {
 // console.log('LineNode in onstate', changed, current, previous);
			if (changed.group && current.group) {
				// this.createMap(current.permalink);
				//this.getPermalink(current.urlParams.config)
			}
		}
	}
</script>


<style>
.TreeView {
    overflow: scroll;
    height: calc(100vh - 30px);
    width: 360px;
    position: absolute;
}
ul {
	padding-inline-start: 12px;
}
li {
    list-style: none;
	line-height: 10px;
    text-overflow: ellipsis;
    white-space: nowrap;
	width: 98%;
    padding-right: 16px;
    overflow: hidden;	
}
li.line > .icons span.cont-center {
	visibility: hidden;
}
li.line:hover > .icons span.cont-center {
	visibility: visible;
}
/*
*/

svg {
	pointer-events: none;
}

svg {
    height: 14px;
    width: 14px;
}
.expanderCont {
    margin-left: -20px;
}

.pointer {
    cursor: pointer;
}

input.expander:checked + span.expander svg {
    transform: rotate(-90Deg);
}

.legend {
	padding-left: 25px;
}
input.check.visibility ~ .legend {
    display: none;
}
input.check.visibility:checked ~ .legend {
    display: block;
}
.gmx-style-legend .legendIconCell.style {
    top: 0px;
    position: relative;
}
.gmx-style-legend .legendIconCell {
    width: 100%;
}
.legendIconEye.enabled > .on, .legendIconEye > .off {
    display: inline-block;
}
.legendIconEye > .on, .legendIconEye.enabled > .off {
    display: none;
}

/*
.gmx-style-legend .legendIconStyle {
    background-color: rgb(255, 0, 0);
    border-color: rgb(0, 0, 255);
    border: solid;
    border-width: 1px;
    border-radius: 2px;
}
*/

.line input.expander:checked ~ ul {
    display: block;
}

.line input.expander ~ ul {
    display: none;
}
.collapse {
    display: none;
}
/*
.cont-center {
	visibility: hidden;
}
li.line:hover .cont-center {
	visibility: visible;
}

*/
span.cont-overlays {
    position: absolute;
    left: 4px;
	padding-top: 4px;
}
span.icons {
    right: 2px;
    position: absolute;
}
.hidden {
    visibility: hidden;
}

</style>
